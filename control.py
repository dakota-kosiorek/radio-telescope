# Dakota Kosiorek & Will Wax
import numpy as np
from numpy.typing import NDArray 
from typing import Annotated
import tkinter as tk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import serial
import time
import astro

# TODO: get working when loc_norm is X, Y, or Z

def theta_phi_to_cartesian(t, p, r) -> Annotated[NDArray[np.float64], (3,)]:
    '''
    Computes the `(x,y,z)` coordinates of a point given by `theta` and `phi` on a sphere of radius `r`.
    '''
    return r * np.array([
        np.sin(p) * np.cos(t),
        np.sin(p) * np.sin(t),
        np.cos(p)
    ])

def cartesian_to_theta_phi(p):
    x = p[0]
    y = p[1]
    z = p[2]

    theta = np.arccos(x / np.sqrt(x**2 + y**2)) if x !=0 and y != 0 else 0
    phi = np.arccos(z)
    
    return np.array([theta, phi])

def normalize(v):
    '''
    Normalizes a vector `v` by dividing its components by its magnitudes.
    '''
    return np.array(v / np.linalg.norm(v))

def calculate_intersection(n_points, r, norm, offset_angle):
    # Number of points to generate for the intersection circle
    points = []

    w = np.sin((offset_angle*np.pi/180))
    offset = w * norm

    r = np.sqrt(r**2 - np.power(np.dot(norm, offset) / np.linalg.norm(norm), 2))

    # Vector 1: perpendicular to normal, in the plane of intersection
    v1 = normalize(np.array([1, 1, -(norm[0]+norm[1]) / norm[2]]))

    # Vector 2: perpendicular to both the normal vector and v1
    v2 = normalize(np.cross(norm, v1))

    # Parametrize the circle using the angle around the circle (theta)
    for i in range(n_points):
        angle = 2 * np.pi * i / n_points
        
        # Parametrize the circle along v1 and v2
        x = r * np.cos(angle) * v1[0] + r * np.sin(angle) * v2[0]
        y = r * np.cos(angle) * v1[1] + r * np.sin(angle) * v2[1]
        z = r * np.cos(angle) * v1[2] + r * np.sin(angle) * v2[2]
        
        points.append([x,y,z])

    # Convert the list of points to a numpy array
    points = np.array(points) + offset
    return points

# Rodrigues' rotation formula
def rotate_point(point, axis, theta):
    '''
    `point`: Cartesian
    '''
    # Convert inputs to numpy arrays
    point = np.array(point)
    axis = np.array(axis)
    theta = np.deg2rad(theta)
    
    # Normalize the axis
    axis = (axis / np.linalg.norm(axis))
    a, b, c = axis

    # Rotation matrix using Rodrigues' formula
    K = np.array([[0, -c, b], 
                  [c, 0, -a], 
                  [-b, a, 0]])

    I = np.eye(3)
    R = I + np.sin(theta) * K + (1 - np.cos(theta)) * (np.dot(K, K))

    # Apply rotation
    rotated_point = np.dot(R, point)
    rotated_point = rotated_point / np.linalg.norm(rotated_point)
    
    return np.array(rotated_point)

def main():
    arduino = serial.Serial(port='/dev/ttyACM0', baudrate=115200, timeout=.1)
    time.sleep(1)

    # Latitude and longitude of RIT (in degrees)
    lng = -77.675936
    lat = 43.082149

    offset_angle = 20 # degrees

    # Convert latitude and longitude to radians
    theta = np.deg2rad(lng) # Longitude
    phi = np.deg2rad(lat) # Latitude

    # Earth's diameter and radius (in kilometers)
    e_diam = 12_756  # Earth's diameter in kilometers
    e_radius = e_diam / 2  # Earth's radius in kilometers

    X = np.array([1, 0, 0])
    Y = np.array([0, 1, 0])
    Z = np.array([0, 0, 1]) # Absolute celestial north

    #  Calculate the 3D Cartesian coordinates of the given location and normalize
    loc_norm = normalize(theta_phi_to_cartesian(theta, phi, e_radius))
    print(f'RIT location norm: {loc_norm}')

    offset = np.sin((offset_angle*np.pi/180)) * loc_norm
    offset_r = np.sqrt(1 - np.power(np.dot(loc_norm, offset) / np.linalg.norm(loc_norm), 2))

    # Subtract Z from the projection of Z onto the plane generated by the location normal vector
    Z_relative = Z - loc_norm
    Z_relative = normalize(Z_relative) if not np.allclose(Z_relative, np.array([0, 0, 0])) else Z

    point_split = None 

    if not (np.allclose(Z_relative, X)):
        point_split = -1 * np.cross(Z_relative, X)
    else:
        point_split = -1 * np.cross(Z_relative, Y)

    root = tk.Tk()
    root.title("Plot with Tkinter Widgets")

    # ====== Left Frame for Plot ======
    left_frame = tk.Frame(root)
    left_frame.pack(side=tk.LEFT, padx=10, pady=10)

    fig, ax = plt.subplots()
    canvas = FigureCanvasTkAgg(fig, master=left_frame)

    canvas.get_tk_widget().pack()

    # ====== Right Frame for Widgets ======
    right_frame = tk.Frame(root)
    right_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=10, pady=10)

    coord_label = tk.Label(right_frame, text="Click the plot")
    coord_label.pack(pady=5)

    def on_click(event):
        nonlocal arduino
        if event.inaxes:
            reset_plot()
            x, y = event.xdata, event.ydata
            point = np.array([x, y, 0])
            point_len = np.linalg.norm(point)

            if point_len <= offset_r:
                point[2] = np.sqrt(1 - x**2 - y**2) # get the z component (this is a unit vector)

                ax.plot(point[0], point[1], 'o', color='green')
                coord_label.config(text=f"Clicked at ({x:.2f}, {y:.2f})")
                canvas.draw()

                # for t in range(15, 360, 15):
                #     p = rotate_point(point, Z_relative, t)

                #     if np.dot(point_split, p) > 0 and np.linalg.norm(np.array([p[0], p[1], 0])) < offset_r:
                #         ax.plot(p[0], p[1], 'o', color='orange')
                #     else:
                #         ax.plot(p[0], p[1], 'o', color='green')
                    
                #     points.append(p)
                
                # Reset

                theta_phi_point = cartesian_to_theta_phi(point)
                theta = theta_phi_point[0]
                phi = theta_phi_point[1]
                
                sign = 0
                if point[1] < 0:
                    sign = 1

                s = f'G{sign}{theta:1.3f};{phi:1.3f}'
                print(s)

                arduino.reset_input_buffer()
                arduino.write(bytes(f'G{sign}{theta:1.3f};{phi:1.3f}', 'utf-8'))

                while True:
                    time.sleep(0.05)
                    response = arduino.readline().decode().strip()
                    if response:
                        print(response)
                        if response.startswith('DONE'):
                            #astro.record_and_process(5, 2.4e6, 2.4e6 * 0.25, 1420.405751768e6, 15, './recording.bin')
                            #astro.record_and_process(5, 2.4e6, 2.4e6 * 0.25, 89.7e6, 15, './recording.bin')
                            break    
    def reset_plot():
        ax.cla()
        ax.set_xlim(-1, 1)
        ax.set_ylim(-1, 1)
        ax.axhline(0, color='black')
        ax.axvline(0, color='black')
        ax.add_patch(plt.Circle((0, 0), 4, color='black'))
        ax.add_patch(plt.Circle((0, 0), 1, color='blue'))
        ax.add_patch(plt.Circle((0, 0), offset_r, color='white'))
        ax.plot([0, 0], [0, 1], color='red') # North
        ax.grid(True)
        canvas.draw()
        coord_label.config(text="Click the plot")

    def quit_plot():
        root.quit()
        root.destroy()

    reset_plot()
    root.protocol("WM_DELETE_WINDOW", quit_plot)
    canvas.mpl_connect("button_press_event", on_click)

    reset_button = tk.Button(right_frame, text="Reset Plot", command=reset_plot)
    reset_button.pack(pady=5)

    entry = tk.Entry(right_frame)
    entry.pack(pady=5)
    entry.insert(0, "Enter something")

    example_button = tk.Button(right_frame, text="Do Something", command=lambda: print('EMPTY') if len(entry.get().strip()) == 0 else print(entry.get()))
    example_button.pack(pady=5)

    root.mainloop()

if __name__ == '__main__':
    main()